#   zpaq.pod - zpaq v6.57 man page source
#
#   Copyright
#
#      Copyright (C) 2014 Dell Inc.
#
#   License
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   Description
#
#	To learn what TOP LEVEL section to use in manual pages,
#	see POSIX/Susv standard and "Utility Description Defaults" at
#	http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_11
#
#	This is manual page in Perl POD format. Read more at
#	http://perldoc.perl.org/perlpod.html or run command:
#
#	    perldoc perlpod | less
#
#	To check the syntax:
#
#	    podchecker *.pod
#
#	Create manual page with command:
#
#	    pod2man PAGE.N.pod > PAGE.N

=pod

=head1 NAME

zpaq - Journaling archiver for incremental backups.

=head1 SYNOPSIS

zpaq I<command> I<archive> [I<files>]... [-I<options>]...

=head1 DESCRIPTION

I<zpaq> manages journaling archives for incremental user-level backups
that conform to I<The ZPAQ Open Standard Format for Highly Compressed Data>
(see I<AVAILABILITY>). The format supports encrypted, deduplicated, and
compressed archives with rollback capability.
It supports archives as large as 1000 times available memory or up to
250 TB and 4 billion files, interoperable between Windows
and Unix/Linux/OS X.

A ZPAQ journaling archive is a sequence of timestamped updates,
each listing the files and directories that have been added, changed, or
deleted since the previous transacted update, normally based on changes to the
last-modified dates. Each new or modified file is split into fragments along
content-dependent boundaries determined by a rolling hash function,
and the SHA-1 hashes are computed and compared with previously stored
fragments. Unmatched fragments are then grouped by file type and
packed into blocks compressed or decompressed independently in parallel
by separate threads. The fragment sizes and hashes and the file
names with their
last-modified dates, attributes, and fragment pointer lists are stored
in a separate index at the end of each update, allowing this information
to be read quickly in large archives by skipping over the data blocks.

Blocks are compressed using LZ77, BWT, or context
mixing with filters, depending on the compression level selected and on
statistics collected during fragmentation. Already compressed data is
detected and stored without further compression.
The decompression algorithms are saved in the block
headers using an interpreted (JIT-accelerated for x86 and x86-64) sandboxed
virtual machine language called ZPAQL. This allows older versions of C<zpaq>
to read archives produced by newer versions when improved compression
algorithms are developed.

To support remote backups, archives may be split into separate updates
plus a small, local index file containing a copy of the entire archive
except for file contents (data blocks). If the archive is moved offsite,
then you can still list, compare, and create updates with just the index.
You can also create an index without a corresponding archive if you
just want to keep a history of file system changes.

Archives are divided into blocks protected by scannable headers, SHA-1
hashes, and redundant copies of fragment size lists to detect damage and
allow partial recovery. Updates are transacted so they can be interrupted
safely. No temporary files are created.

Archives may be encrypted with AES-256 in CTR mode, providing
secrecy but not tamper resistance. The key is strengthened by
Scrypt(SHA-256(password), salt, N=16384, r=8, p=1) using
a 32 byte random salt that is prefixed to the archive. This slows
down brute force password searches by requiring over 206 million
32-bit operations and 16 MiB memory per test. Multi-part archives
are encrypted with a single keystream as if concatenated. The index,
if present, is encrypted with the same password but a different
salt and keystream.

=head1 COMMANDS

I<command> is one of C<add>, C<compare>, C<delete>, C<extract>, C<list>,
C<purge>, or C<test>. Commands may be abbreviated to one letter.

I<archive> is assumed to have a C<.zpaq> extension if not specified.
Wildcards C<*> or C<?> in I<archive> specify a multi-part archive
to support remote backups. C<*> and C<?> are replaced with part numbers
or single digits of the part number, respectively. Parts 1
and higher are interpreted as if they were concatenated in consecutive
numerical order. Part 0 is an optional index containing a copy of the archive
except for file contents. For example, C<part??> would refer
to C<part00.zpaq> (index), C<part01.zpaq> (first update), C<part02.zpaq>
(second update), etc. The index is only needed if the other parts
are removed. Otherwise it is ignored.

I<files> is a list of file and directory names separated by spaces. If a
name is a directory, then it recursively includes all
files and subdirectories within.

Depending on the command,
I<files> may refer either to internal files and directories (stored in the
archive) or external files and directories (stored on disk), or both.
File names may contain wildcards. When referring to internal names,
the wildcard C<*> matches any string of zero or more characters
(including C</>) and C<?> matches exactly one character.
In Unix/Linux, C<*> should be escaped as C<\*> or the name should be
enclosed in quotes to protect it from the shell. When referring
to external names, C<zpaq> expands wildcards only in Windows, and only
in the last component of the path (after the last C</> or C<\>).

In Windows, C<\> matches C</> and upper case matches lower case.

=over

=item a

=item add

Append changes in I<files>
to I<archive>, or create I<archive> if it does not exist. If I<archive>
contains wildcards indicating a multi-part archive, then create a new
part using the next available part number starting with 1. If an index
(part 0) is present, then it is also checked for consistency (number
of versions and archive size) and updated. An index is created only if
part 1 is also created. If the index is present but part 1 is not, then
the number of versions in the index is counted and a new part is created
using the next available version number, and the index is updated.

A change is an addition, update, or deletion of any file or directory in
I<files> or any of its subdirectories to any depth. A file or directory is
considered changed if its size, last-modified date (with 1 second resolution),
or Windows attributes or Unix/Linux permissions differ between the internal
and external versions. File contents are not compared.

For each added or updated file or directory, the following information is saved
in the archive: the compressed contents, the file or directory name as it
appears in I<files> plus any trailing path, the last-modified
date with 1 second resolution, and the Unix/Linux permissions or Windows
attributes. Other metadata such as owner, group, ACLs, alternate streams,
last access time, etc. are not saved. Symbolic links are not saved or followed.
Hard links are followed as if they were ordinary files. Special file types
such as devices, named pipes, and named sockets are not saved.

If any file cannot be read (e.g. permission denied), then it is skipped and
an error is reported. However, other files are still added and the update
is still valid.

Updates are transacted. If C<zpaq> is interrupted before completing
the update, then the partially appended data is ignored and overwritten on the
next update. This is accomplished by first appending a temporary update header,
appending the compressed data and index, then updating the header as the
last step.

If I<archive> is C<""> (a quoted empty string), then C<zpaq> compresses
I<files> as if creating a new archive, but discards the output without
writing to disk.

=item c

=item compare

Compare contents of I<files> between the archive and disk and list
any differences. If I<files> is omitted, then compare all of the files
in the archive with files on disk. Files are compared first by size,
and if identical, then by computing the fragment SHA-1 hashes of the
file on disk and comparing with the stored hashes.
Any differences are listed (as in C<list>) using a leading ">" character
to represent the internal file and "<" to represent the external file.
Files are considered identical (and not listed) even if the dates
and attributes/permissions differ.

=item d

=item delete

Update the archive such that I<files> (and contents
of directories) are internally marked as deleted.
It is equivalent to C<add> when the external files do not exist.
Thus, it makes the archive larger. (Use C<purge> to permanently remove
deleted files).

=item e

=item x

=item extract

For each of the named I<files>, extract the files (or directories) to disk.
If I<files> is omitted, then the entire archive is extracted.
The last-modified date and permissions or attributes
are set as saved in the archive.
Existing output files are skipped without generating an error.
(Use C<-force> to overwrite. Use C<-quiet 0> to report individual
skipped files).

As files are extracted, the fragment SHA-1 hashes are computed and compared
with the stored hashes. The program reports an error in case of mismatches.
Blocks are only decompressed up to the last used fragment. Thus, the block
SHA-1 hash is not normally checked.

If C<zpaq> runs out of memory, then it kills a thread and continues extracting
with the remaining threads. If only one thread is left then it is an error.

If a fragment table block is damaged, then C<zpaq> recovers the fragment
sizes (but not hashes) from a copy of the list at the end of the data block.
Data integrity is verified by the block hash rather than the fragment
hashes.

If a data block is damaged, then any files pointing to fragments in those
blocks cannot be extracted. If a file points to both damaged and undamaged
data blocks then the file will be partially extracted and may be filled
with fragments containing zero bytes. C<zpaq> will report such errors.

If an index block is damaged, then any files listed within are lost. In
case of an update or deletion, the earlier version will be extracted. The
index is split into blocks of about 16 KB to limit damage.

If an update header block is lost, then C<zpaq> will scan past the data blocks
searching for the 13 byte header tag of the first index block.
No files are lost.

Damaged blocks are detected by errors parsing the header, decompression
errors such as runaway decompression exceeding the expected output size,
parsing errors in the decompressed data, or a mismatch between the SHA-1
hash of the decompressed block and the hash stored in the block trailer.

=item l

=item list

For each of the named I<files>, list the version number, last-modified
date (UT time zone), file name, attributes or permissions, size,
and approximate compression ratio.
If I<files> is not specified then list the entire archive contents.
The version number refers to the number of times the archive was updated
up to and including the update that added the file.

Attributes are listed as an octal number in Unix/Linux (as per C<chmod(1)>)
or with the letters D, A, S, H, R, I in Windows (as per the C<attrib>
command).

The compression ratio is estimated
from the ratio of the blocks containing the fragments, weighted by
fragment size. It does not account for deduplication (shared fragments).

If I<archive> is multi-part (like C<part??.zpaq>), then parts 1 and higher
are listed, ignoring the index. To list the index (C<part00.zpaq>),
specify the index file (like C<zpaq list part00>). This should give the same
result if the index is correct.

=item p

=item purge

Permanently remove old versions and deleted files from the archive, keeping only
the contents of the latest version. The C<-to> option is required
to specify the output archive. I<archive> is not modified. This is
the only way to make an archive smaller. The output is not encrypted by default,
even if the input is.

An archive is purged by keeping any data block and the corresponding
fragment table block if any of the fragments are pointed to by any files
in the latest version. Unused fragments are not removed because it would
require decompressing and recompressing the block.
Then a new header is written with the current
date, and new fragment tables and index blocks are written with old
versions removed and fragments renumbered consecutively.

=item t

=item test

Test the archive by extracting I<files>, computing their SHA-1 hashes,
comparing with the stored hashes, then discarding the output
without writing to disk. If I<files> is omitted, then test all files
in the latest version. (Use C<-all> to test all versions).

=back

=head1 OPTIONS

Options may be abbreviated as long as it is not ambiguous.

=over

=item -all

With C<compare>, treat files as different if only the last-modified
date or attributes/permissions differ.

With C<list>, list all saved versions and not just the latest version,
including versions where the file is marked as deleted. Also show
a table of archive versions. Each entry in the version table shows
the version number (starting with 1), number of file fragments to
this point, the date and time of the update (UT time zone), number of
files added or updated, number of files deleted, and the uncompressed
and compressed sizes of the update.

With C<purge>, keep all versions, which has the effect of simply
copying the archive. This option is useful when combined with
C<-key> and C<-newkey> to encrypt, decrypt, or change the password
of an encrypted archive.

With C<test>, test all versions of each file and not just the latest.
Also verify data block SHA-1 checksums.

=item -duplicates

With C<list>, list the contents sorted by decreasing size and label each listing
with "=" (instead of ">") if the file contents are identical to the
previous one.

=item -force

With C<add>, do not assume that files are identical just because the
last-modified date, size, and attributes/permissions match. However,
files are only added if they really are different. Files are assumed
identical if the computed SHA-1 hashes match those stored in the archive.

With C<extract>, overwrite existing output files if they differ. If the
contents differ (tested by comparing SHA-1 hashes), then the file is
decompressed and extracted. If the dates or attributes/permissions
differ, then they are set to match those stored in the archive.

=item -fragile

With C<add> and C<delete>, do not save extra data used for error detection
and recovery. This includes a 13 byte locator tag that allows compressed
blocks to be found after corrupted data, block SHA-1 checksums for
error detection, and the redundant list of fragment sizes stored in data
blocks which can be used to recover from corrupted fragment tables. This
produces slightly smaller archives and slightly speeds up compression.

With C<extract>, do not compute SHA-1 hashes of the output files as they
are extracted to compare with the stored fragment hashes. This slightly
speeds up decompression, but output errors from corrupted archives would
go undetected.

With all commands, do not verify block checksums when reading the archive.

=item -fragment I<N>

Set the average dedup fragment size to 2^I<N> KB. I<N>
can range from 0 (1 KB) to 1/8 of the block size.
The default is 6 (64 KB). Deduplication works by splitting large files
along content-dependent boundaries, computing their SHA-1 hashes, and
comparing them with the hashes of previously stored fragments. If there
is a match, then only a pointer to the matching fragment is stored.
A smaller fragment size can result in better compression, but requires
more space to store fragment tables and hashes both in memory and in
the archive. Updates across versions that use different values
of I<N> will fail to detect identical files, resulting in wasted space.

=item -key [I<password>]

This option is required for all commands operating on an encrypted archive.
When creating a new archive with C<add>, the new archive will be encrypted
with I<password> and all subsequent operations will require the same
password. A password may contain multiple words separated by single spaces
provided no word begins with "-" indicating the start of the next option.

If I<password> is omitted then C<zpaq> will prompt for it without echoing
to the screen. When creating a new archive, it will prompt until
the same password is entered twice in a row.

When creating a new archive, a 32 byte salt is generated
using CryptGenRandom() in Windows or from /dev/urandom in Unix/Linux,
such that the first byte is different from the normal header
of an unencrypted archive (C<z> or C<7>).

=item -method {0|1|2|3|4|5}[I<N1>]

=item -method {x|s|i}[I<N1>[{,|.}I<N2>]...][[fI<cfg>|c|i|a|m|s|t|w][I<N1>][{,|.}I<N2>]...]...

With C<add>, select a compression level or algorithm, respectively.
In the first form, higher numbers compress better but slower and
(except for 2) also decompress slower. 0 means no compression.
In the second form, the arguments describe the exact algorithm to be applied
to all blocks (which might otherwise vary based on an analysis of the block).
The default for regular archives is C<-method 1>,
which is good for fast backups. C<-method 2> is useful for archives that
will be compressed once and extracted many times.
If I<archive> is detected to be an index, then the default is C<-method i>.

In both forms, I<N1> in range 0..11 optionally specifies a maximum block
size of 2^I<N1> MiB. The default is 6 (64 MiB) for levels
2..5 and 4 (16 MiB) otherwise. Larger blocks usually compress better.
The memory requirement for compression and decompression is up to 8 times the
block size per thread for methods 1..4 and 16 times for 5. Thus,
the default is C<-method 14>, requiring 128 MiB memory per thread.

In the second form, the arguments to C<x> or C<s> describe how the
input block is transformed prior to context modeling. C<zpaq>
performs the transform and inserts ZPAQL code into the beginning of
each block before compression to perform the inverse transform.

=over

=item x

Compress in journaling format like 0..5, but compress all blocks the same.

N1 selects the block size as before. Default is 4.

N2 selects an encoding step as follows:

    0 = no transform.
    1 = LZ77 with variable length codes (default).
    2 = LZ77 with byte-aligned codes.
    3 = BWT.
    4..7 = 0..3 with E8E9 transform applied first.

The E8E9 transform scans the input block from back to front for
5 byte sequences of the form (E8|E9 xx xx xx 00|FF) and adds
the block offset of the sequence start (0..n-4) to the middle 3 bytes,
interpreted LSB first. It improves the compression of x86 .exe and .dll files.

BWT (Burrows-Wheeler transform) does not compress by itself but makes
the data more compressible with a low order context model. It
sorts the block by suffix with an implied terminator of -1 encoded
as 255. The 4 byte offset of this terminator is appended to the end
of the block LSB first, thus increasing the block size by 5. Memory
required is 5x block size for both compression and decompression.

LZ77 compresses by replacing duplicate string matches with pointers
(offset and length) to a previous occurrence. Unmatched bytes are
coded as literal strings. Byte aligned LZ77 encodes as follows:

    00xxxxxx   x+1 (1..64) literals follow
    yyxxxxxx   match of length x+N3 (N3..N3+63), with y+1 (2..4)
               bytes of offset-1 to follow, MSB first.

For example, literal "ab" would be coded:

    00000001 01100001 01100010

A match of length 4 and offset 9 with minimum match length N3 = 4
would be coded:

    01000000 00000000 00001000

LZ77 with variable length codes is designed for compression with no
further context modeling. Bit codes are packed LSB first. The last
byte of the compressed stream is padded with 0 in the high bits if
necessary. Literals are coded as follows:

    00,n,L[n] = n literal bytes

where n is written using an interleaved Elias Gamma code: the leading
1 is dropped from the binary value of n and the other bits are preceded
by 1 and terminated by 0. For example:

    1 = 1 = 0
    2 = 10 = 1,0,0 = 001
    3 = 11 = 1,1,0 = 011
    4 = 100 = 1,0,1,0,0 = 00101
    5 = 101 = 1,0,1,1,0 = 01101

For example, string "ab" (01100001 01100010) is coded in 3 bytes
as follows. (Hyphens show original field boundaries for clarity).

    00,1,0,0,01100001,01100010 = 001-0-0-1-00 010-01100 000-01100

Matches for blocks up to 16 MiB (N1 = 4) are coded as follows:

    mm,mmm,n,ll,q[m]

The length is 4n + ll, where n is Elias Gamma coded.
Lengths less than 4 cannot be coded.
The offset is 2^m + q + 1 where q is written in m = 8mm + mmm - 8
(0..23) bits. For example, a match length of 4 and offset 9 would
be coded with m = 3:

    01,011,0,00,000

For larger blocks that require more than 23 offset bits, an extra
field (r) of length N1 - 4 is inserted to represent the low bits.

    mm,mmm,n,ll,r[N1-4],q[m]

The offset is 2^(m+N1-4) + r + (q-1)2^(N1-4) + 1. For example, if
the block size is 64 MiB (N1 = 6) then the above example would
be written with m = 1 and r = 00.

    01,001,0,00,00,1

N3 through N8 affect only LZ77 compression as follows:

N3 = minimum match length. If the longest match found is less than N3,
then literals are coded instead. It must be at
least 4 for LZ77 with variable length codes and in range 1..63
for byte aligned LZ77.

N4 = context length to search first (normally N4 > N3), or 0 to skip
this search.

N5 = search for 2^N5 matches of length N4 (unless 0), then 2^N5 more
matches of length N3. The longest match is chosen, breaking ties by
choosing the closer one.

N6 = use a hash table of 2^N6 elements to store the location of context
hashes. It requires 4 x 2^N6 bytes of memory for compression only.

If N6 - N1 >= 21 then use a suffix array instead of a hash table to search
for matches. It adds 4.5 x 2^N1 MB memory for compression only
(4 for the suffix array and 0.5 for the partial inverse suffix array
rebuilt 8 times). Matches are found by scanning the suffix array
forward and backward up to 2^N5 positions each way to find the longest
match of at least N3. N4 has no effect.

N7 = lookahead for secondary context. LZ77 will compare the next N4 + N7
bytes, allowing the first N7 not to match and code them as literals.
If N6 selects a suffix array (N6 - N1 >= 21, N5 not used), then lookahead
is applied to N3. (Usually does not improve compression).

For example, C<-method x6,1,4,0,3,24,0> selects a block size
of 2^6 MiB, LZ77 with variable length codes (1), minimum match length
of 4, no secondary match, hash table search depth 2^3 = 8, hash table
size of 2^24 elements, and no lookahead. It requires 192 MiB per thread
to compress (2 x 64 MiB buffers and 64 MiB hash table). The default
is C<-method x4,0> which selects no compression.

=item s

Store in streaming format rather than journaling. Streaming mode is
compatible with zpaq versions prior to 6.00 but does not support
deduplication or storing directories. Each file is stored
in a separate block. Large files are split into blocks of size
2^(N1+20) - 4096 bytes. Block sizes, dates, and attributes
are stored in the first segment comment header of the first block
as "size YYYYMMDDHHMMSS wN" (or "uN") all as decimal numbers. Subsequent
blocks of the same file store only the size and leave the filename blank
as well. Compression is single threaded. Parameters are the same as x.

=item i

Discard the blocks after compression. This creates an index with
a list of files and their hashes, but without the file contents.
It is an error to update a non-index archive as an index or vice versa.

=back

Subsequent groups after methods C<x> and C<s>
beginning with a letter specify context models. zpaq
compresses by predicting bits one at a time and arithmetic coding.
Predictions are performed by a chain of context models, each taking
a context (some set of past input bits or their hash) and possibly
the predictions of other components as input. The final component
in the chain is used to assign optimal length codes. The context
model is translated to ZPAQL and executed during both compression
and decompression.

Memory usage per component is generally limited to the block size, but
may be less for small contexts. The numeric arguments to each model
are as follows:

=over

=item c

Specifies a direct context model (CM) or indirect context model (ICM).
A CM translates a context hash to a prediction using a lookup table that is
adjusted in proportion to 1/count (up to a maximum)
after each prediction to reduce the error. An ICM maps a context hash to
an 8-bit state representing the bit sequence history seen in that context,
then maps the history to a prediction as with a CM but with a small,
fixed error adjustment. An ICM is usually better at adapting to changing data.

N1 is 0 for an ICM and 1..256 to specify a CM with limit argument N1-1.
Higher values are better for stationary sources.

If N1 is 1000 or more, then memory usage is adjusted by a factor of
2^-floor(N1/1000), and the component type is determined by N1%1000. Default
memory usage depends on the number of bits of context, not to exceed the
block size. The usage is otherwise 2^sb bytes, where sb is initially
11 (2 KB) and increased by the contexts below.

N2 in 1..255 includes (offset mod N2) in the context hash. It increases
sb by floor(log2(N2))+1.  N2 in 1000..1255 includes the distance to the
last occurrence of N2-1000 in the context hash. It increases sb by 6
(memory usage by a factor of 64). For example, C<c0,80> is an ICM
whose context is the column number in a database with 80 byte records.
C<c256,1010> is a stationary CM whose context is the column number
in a text file (lines delimited by linefeeds, ASCII 10).

N3,... in 0..255 specifies a list of byte context masks reading back from
the most recently coded byte. Each mask is ANDed with the context byte
before hashing. Each such context increases sb by floor(nbits(N)*3/4)
where nbits(N) is the number of bits set in N. Thus, N=255 increases
sb by 6 (memory usage by 64). For example, C<c0,0,255,255,255> is an
ICM with an order 3 context.

A value of N = 1000 or more is equivalent to a sequence
of N-1000 zeros. Only the last 65536 bytes of context are saved.
For byte aligned LZ77 only, N in 256..511 specifies either the LZ77
parse state if a match/literal code or match offset byte is expected,
or else a literal byte ANDed with the low 8 bits as with 0..255. For example,
C<-method x4,6,8,0,4,24c0,0,511> specifies E8E9 + byte aligned LZ77 (6),
and an order 1 ICM context model that includes the LZ77 parse state.

The default arguments are all 0.

=item i

ISSE chain. Each ISSE takes a prediction from the previous component
as input and adjusts it according to the bit history of the specified
context. There must be a previous component. N1 specifies the context
order of the first component. The context is hashed together with the
previous component. The arguments N2,N3,... specify an increase of N in
the context order from previous component's context.
For example, C<-method x4,3ci1,1,2> specifies a 16 MB block (4), BWT (3),
followed by an order 0 ICM (c) and an ISSE chain of 3 components with
context orders 1, 2, and 4.

If N is 10 or higher, then the context order is increased by N%10 and
memory usage is halved for each increment of floor(N/10). The default
memory usage of each ISSE component in the chain is 64 times the
previous component for each increment of the context order up to a maximum
of the block size. For example, C<-method x4,3ci1,1,2>
would specify 2 KiB (default
memory usage for a ICM with no other context), 128 KB for the first ISSE,
8 MiB for the second ISSE, and 16 MB (the block size) for the third ISSE.
C<ci1,11,12> would reduce the second and third ISSE to 4 MiB and 8 MiB
respectively.

=item a

Specifies a MATCH. A MATCH maintains a history buffer and a hash table
index to quickly find the most recent occurrence of the current context
and predict whatever bit follows. If a prediction fails, then it makes
no further predictions for the rest of the byte and then it looks up
the context hash on the next boundary. The hash is computed as the
xN1 + 18 - N3 low bits of hash := hash*N1+c+1 where c is the most recently
coded byte and xN1 is the block size as specified by x. N2 and N3 specify
how many times to halve the memory usage of the buffer and hash table,
respectively. For example, C<-method x4,0a24,0,1> specifies a 16 MiB block
for compression (x4) with no preprocessing (0). The match model uses
a multiplier of 24, a history buffer the same size as the compression
buffer (0), and a hash table using half as much memory (1). This means
that the hash table index is 4 + 18 - 1 = 21 bits. The multiplier of 24
when written in binary has 3 trailing 0 bits. Thus, it computes a hash
of order 21/3 = 7. A high order match is most useful when mixed with
other low-order context models. Default is C<a24,0,0>

=item m

Specifies a MIX. A MIX does weighted averaging of all previously specified
components and adapts the weights in favor of the most accurate ones.
The mixing weights can be selected by a (usually small) context for
better compression.

N1 is the context size in bits including those of the byte being modeled.
The context is not hashed. If N1 is not a
multiple of 8 then the low bits of the oldest byte are discarded.
A good value is 0, 8, or 16. N2 specifies the update rate in 0..255.
A good value is around 16 to 32 with higher numbers adapting faster.
For example, C<-method x6,0ci1,1,1m8,24> specifies
64 MB blocks, no preprocessing, an order 0-1-2-3 ICM-ISSE chain with a
final mixer taking all other components as input, order 0 (bitwise order 8)
context, and a learning rate of 24. Default is C<m8,24>. Memory usage is
M x 2^(N1+2) bytes up to M times the block size, where M is the number of
mixer inputs.

=item t

Specifies a MIX2. The input is only the previous 2 components. N1 and N2
are the same as MIX. For example,
C<-method x6,0ci1,1,1m8,10m16,32t0,24> specifies the previous model with
2 mixers taking different contexts with different learning rates, and
then mixing both of them together with no context and a learning rate of 24.
Default is C<t8,24>. Memory usage is 2^(N1+2) bytes.

=item s

Specifies an SSE. An SSE, like an ISSE, uses a context to adjust the
prediction of the previous component, but does so using the direct
context (via a 2-D lookup table of the quantized and interpolated
prediction) rather than a linear adjustment based on the bit history.
Thus, it has more parameters, making a smaller context more appropriate.

The input is the previous component. N1 is the unhashed context
size in bits as in a MIX or MIX2. N2 and N3 are the start and limit
arguments, where higher values specify lower initial and final learning
rates, resulting in lower adaptation rates. Default is C<s8,32,255>.

=item w

Word-model ICM-ISSE chain for modeling text. N1 is the length of the
chain, with word-level context orders of 0..N1-1. A word is defined
as a sequence of characters in the range N2..N2+N3-1 after ANDing
with N4. Default is C<w1,65,26,223,20,0> represents the set [A-Za-z]
using a context hash multiplier of N5 = 20. (hash := hash x N5 + c).
Memory per chain component is 2^-N6 times block size.

=item fI<cfg>

Specifies a custom configuration file I<cfg> containing ZPAQL code
describing the compression algorithm. The file is assumed to have a
C<.cfg> extension. No other components should be present. For example,

    -method x4.0fconfig

would specify 2^4 = 16 MiB blocks, no pre/post processing (0), and to compress
using the description in C<config.cfg>. The format for a configuration file is:

    COMP hh hm ph pm n
        0 component args...
        1 component args...
        ...
        n-1 component args...
    HCOMP
        ZPAQL context modeling code...
    [PCOMP preprocessor-command ;
        ZPAQL post-processing code...]
    END

where the n components (numbered 0 to n-1) and ZPAQL instructions
are as described in sections 3 and 5 of the ZPAQ specification.
If I<n> is 0 then the C<COMP> and C<HCOMP> sections should be present
but empty.

The C<PCOMP> section specifies how the output should be post-processed
after decompression. Normally I<preprocessor-command> would be the name
of a program (taking input and output filename arguments) that would
perform the inverse operation, but this feature is not supported.
If I<N2> is 0 specifying no pre/post-processing as above
then the C<PCOMP> section should be omitted.
Otherwise it must contain code to post-process correctly. It is not
automatically generated.

I<hh> and I<hm> specify the sizes of the H and M arrays for the
context modeling virtual machine as 2^I<hh> 32-bit words and 2^I<hm>
bytes respectively. I<ph> and I<pm> do likewise for the post-processor,
if present.

Configuration files are not case sensitive. It is free formatted with
words separated by white space. Comments are enclosed in parenthesis,
which may be nested. In most cases, each word assembles to one byte.
Thus, two byte instructions like C<A+= 5> should be written with a space
between the opcode and operand, for example:

    (equivalent to -method x6.0ci1)
    comp 1 3 0 0 2
        0 icm 5      (indirect context model, size 5)
        1 isse 11 0  (size 11, input from 0)
    hcomp
        c-- *c=a     (save input byte in rotating buffer)
        d= 0 *d=0    (order 0 context for ICM)
        b=c a=*d d++ hash *d=a  (order 1 context for ISSE)
        halt
    end

In this example, arrays H and M are 2 words and 8 bytes, respectively.
The COMP section describes an order 0-1 chain. The contexts are
computed in the HCOMP section and put in H[0] and H[1]. The HCOMP
section is called once per byte to update the contexts with the
previously coded byte in the A register. The ZPAQL virtual machine
has 32-bit registers A (accumulator), B, C (low bits point to M),
D (pointer to H), and condition flag F. This example uses M to
save the last 8 bits of input in a rotating buffer pointed to by C.
The second line puts 0 in H[0], the context for the ICM. The third
line retrieves the context from H[0], hashes it with the context
at M[B], and writes it to H[1]. The HASH instruction updates
A = (A + *B + 512) * 773.

ZPAQL operands are 0..255 except for the jump instructions JT, JF, and JMP,
where the operand is -128..127. The operand of LJ (long jump) is 0..65535.
In most programs it is not necessary to code jump instructions. ZPAQL
supports the following structured programming constructs:

    IF ... ENDIF             (execute ... if F is true)
    IF ... ELSE ... ENDIF    (execute 1st part if true else 2nd)
    IFNOT ... ENDIF          (execute ... if F is false)
    IFNOT ... ELSE ... ENDIF (execute 1st part if false else 2nd)
    DO ... WHILE             (loop while true (test F at end))
    DO ... UNTIL             (loop while false)
    DO ... FOREVER           (loop forever)

These constructs may be nested 1000 deep. However IF statements and DO
loops nest independently and may be crossed. For example, the
following post-processor loop outputs a 0 terminated string
pointed to by *B by breaking out when it finds a 0.
The construct DO IF...FOREVER ENDIF is equivalent to a "while" loop.

    do
        a=*b a> 0 if (JF endif)
            out b++
        forever (JMP do)
    endif

IF, IFNOT, and ELSE are coded as JF, JT and JMP respectively. They can
only jump over at most 127 instructions. If the code in these sections
are longer, then use the long forms IFL, IFNOTL, or ELSEL. These
behave the same but are coded using LJ instead. There are no special
forms for WHILE, UNTIL, or FOREVER. C<zpaq> will automatically
use the long forms when needed.

N1..N9 are passed as arguments $1..$9, except that $1 may be reduced such that
the actual block size is at most 2^$1 bytes. These may be used anywhere
a number is expected, or a constant offset may be added like
C<MATCH $1+2 $1>.

=back

=item -newkey [I<password>]

Set the encryption key for the output of C<purge>. If I<password>
is omitted, then the program will prompt for it without echoing to
the console until the same value is entered twice consecutively.
If the same password is used as C<-key>, the output will still be
different because a new salt will be used (generated as with C<-key>).

=item -noattributes

With C<add>, do not save Windows attributes or Unix/Linux permissions
to the archive. With all commands, ignore values already saved.
Thus, C<extract> will create files with default attributes and
permissions, C<compare -all> will not compare attributes, and
C<list> will not show them.

=item -nodelete

With C<add>, do not mark files in the archive as deleted when the
corresponding external file does not exist. This makes C<zpaq>
consistent with the behavior of most non-journaling archivers.

=item -not I<names>...

=item -not :[+|-|d|a|A|s|h|r|i]...  (Windows)

=item -not :[+|-|d|r|w|x]...  (Unix/Linux)

Exclude each name in I<names> from I<files> so that they are
not added, extracted,
listed, compared, deleted, or tested. Excluding a directory excludes
all of its contents. A name in I<names> may contain wildcards
such that C<*> matches any string and C<?> matches any character
including C</>. Files are excluded before renaming with C<-to>.
For example:

    zpaq add backup home/bob -not home/bob/tmp "*.o"

will exclude everything in C<home/bob/tmp> and exclude all files
ending with C<.o>.

The second and third form exclude files according to their Windows
attributes and Unix/Linux user permissions, respectively. A file is
excluded if all of the listed bits are set when following C<+>
and clear when following C<->. In Windows, d, a, s, h, r, i
are the directory, archive, system, hidden, read-only, and index
attributes, respectively. In Unix/Linux, d, r, w, x are the directory,
user read, user write, and user execute permissions respectively.
(It is not possible to filter on the group and other permissions).
For example:

    zpaq add files -not :+d-xr

means do not add directories that lack both user read and user execute
permission.

In Windows, if the first
attribute is C<A> instead of C<a> then it means to also clear the archive
bit both internally and externally when adding, thus implementing the
intended meaning of this bit. For example, C<-not :-Ad> means do not
add regular files where the archive bit is clear, then clear the archive
bit of those files that are added.

=item -quiet [I<size>[k|m|g]]

With no argument, suppress all console output except error messages
to standard error. With a numeric argument, suppress console display
of file names when smaller than I<size>. 
The suffixes C<k>, C<m>, and C<g> mean KB, MB, and GB respectively.
For example:

    zpaq list backup -quiet 1k

lists all files that are 1000 bytes or larger.

C<add>, C<extract>, and C<test> will display progress,
listing files of size I<size> or greater as they are added or extracted.
Additionally, C<add> will display for each compressed block the
estimated time to completion, fragment range, original and
compressed sizes, time for the thread to compress, a type
determined by analyzing the data, and the compression algorithm
selected based on the type, for example:

    0:00:00 [1-57] 3141858 -> 1142160 (0.48s), 179t x2,1,5,0,3,22

The type is a number in 0..255 with higher numbers predicting
better compression, followed by C<t> if text is detected, C<e>
if x86 (.exe or .dll) is detected, or C<b> if both are detected.
The algorithm is as described in C<-method> (LZ77 in this example).

=item -since [[-]I<version>]

List, compare, or extract only I<version> and later. If I<version> is negative
then list, compare, or extract only the last -I<version> updates.
Default is 0 (all). For example:

    zpaq list backup -since -2

shows files that were added in the last two updates.

=item -threads I<N>

Compress or decompress at most I<N> blocks in parallel. The default
is the number of processor cores, except not more than 2 when when C<zpaq>
is compiled to 32-bit code. Selecting fewer threads will reduce memory
usage but run
slower. Selecting more threads than cores does not help.

=item -to I<names>...

For each internal file in I<files>, replace with the respective name
in I<names> when referencing the corresponding external file on disk.
If I<files> is empty, then prefix each file in the archive with the first
name in I<names> when referencing external files. For example:

    zpaq extract backup alice bob charlie -to dave ed

will extract directory C<alice> to C<dave> (e.g. C<alice/file> to C<dave/file>),
C<bob> to C<ed>, and C<charlie> without renaming.

    zpaq extract backup -to tmp/

will extract C<bob> to C<tmp/bob>.

    zpaq compare backup -to tmp/

will compare internal C<bob> with external C<tmp/bob>.
C<-to> renames in reverse when updating, for example:

    zpaq add backup alice -to dave

will add external C<dave> but save the name as C<alice>.

With C<list>, C<-to> will show how files would be renamed when extracted.

=item -until I<date> | [-]I<version>

Ignore any part of the archive updated after I<date> or after I<version>
updates or -I<version>s from the end if negative.
Additionally, C<add> and C<delete> will truncate the archive at
this point before appending the next update. When a date is specified,
the update will be timestamped with I<date> rather than the current date.

A date is specified as a 4 digit year (1900 to 2999), 2 digit month (01 to 12),
2 digit day (01 to 31), optional 2 digit hour (00 to 23, default 23),
optional 2 digit minute (00 to 59, default 59), and optional 2 digit
seconds (00 to 59, default 59). Dates and times are always universal
time zone (UT), not local time. Numbers up to 9999999 are interpreted
as version numbers rather than dates. Dates may contain spaces and
punctuation characters for readability but are ignored. For example:

    zpaq list backup -until 3

shows the archive as it existed after the first 3 updates.

    zpaq add backup files -until 2014/04/30 11:30

truncates any data added after April 30, 2014 at 11:30:59 universal time,
then appends the update as if this were the current time. (It does
not matter if any files are dated in the future).

    zpaq add backup files -until 0

deletes backup.zpaq and creates a new archive.

With comparing two archives, C<-until> rolls back both archives to
the indicated date or version. If the version is negative, it means
the number of versions from the end of the first archive.

Truncating and appending an encrypted archive with C<add -until>
or C<delete -until> (even C<-until 0>)
does not change the salt or keystream. Thus, it is possible for an attacker
with the old and new versions to obtain the XOR of the trailing
plaintexts without a password. If this is a concern, then the
attack can be prevented by changing the keystream after updating using
C<zpaq purge backup -to new_backup -all -key -newkey>
(same password is OK) and securely deleting C<backup.zpaq>.

=item -with I<archive2>

With C<compare>, compare I<archive> with archive or index
I<archive2> instead of external files. If I<archive2>
does not have a C<.zpaq> extension, then one will be added.
I<files> specifies the files to be compared in both archives
(default: all files). I<-to> renames files in I<archive2>.
For example:

    zpaq compare part00 -with part?? -all

compares an index with the corresponding archive, including dates
and attributes. Both archives may be the same, for example:

    zpaq compare backup dir1 dir2 -to dir2 -with backup

compares C<dir1> with C<dir2> in C<backup.zpaq>.

Files are compared by their fragment hashes. If two files
are compressed with different C<-fragment> options, then the
hashes will be different even if the files are identical. 

=back

=head1 EXIT STATUS

Returns 0 if successful or 1 in case of an error. C<compare>
returns 1 if any files differ.

=head1 ENVIRONMENT

In Windows, the default number of threads (set by C<-threads>) is
%NUMBER_OF_PROCESSORS%. In Linux, the number of lines of the
form "Processor : 0", "Processor : 1",... in F</cpu/procinfo>
is used instead.

=head1 STANDARDS

The archive format is described in
I<The ZPAQ Open Standard Format for Highly Compressed Data>
(see I<AVAILABILITY>).

=head1 AVAILABILITY

http://mattmahoney.net/zpaq/

=head1 BUGS

There is no GUI.

The archive format does not save sufficient information for backing
up and restoring the operating system.

=head1 SEE ALSO

C<bzip2(1)>
C<gzip(1)>
C<lrzip(1)>
C<lzop(1)>
C<lzma(1)>
C<p7zip(1)>
C<rzip(1)>
C<unace(1)>
C<unrar(1)>
C<unzip(1)>
C<zip(1)>

=head1 AUTHORS

I<zpaq> uses code from I<libzpaq> v6.52 and I<libdivsufsort-lite> v2.01.

I<zpaq> v6.57 is copyright (C) 2009-2014, Dell Inc. It is written by Matt
Mahoney. It is licensed under GPL v3, or at your option,
any later version. For information on
the license, see <http://www.gnu.org/copyleft/gpl.html>.
Program was written by Matt Mahoney <matmahoney@yahoo.com>.

I<libzpaq> v6.52 is public domain, written by Matt Mahoney.
It includes some public domain code modified from
libtomcrypt by Tom St Denis and salsa20 by D. J. Bernstein.

I<libdivsufsort-lite> v2.01 is copyright (C) 2003-2008,
Yuta Mori. It is licensed under the MIT license. See the source
code for license text.

=cut

